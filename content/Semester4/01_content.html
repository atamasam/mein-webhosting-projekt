<div>
  <h2>Vorlesung 1: Einführung in Verteilte Systeme (31.03.2025)</h2>
  <p>
    Willkommen zur ersten Vorlesung! Wir behandeln die Grundlagen der
    Netzwerkkommunikation und serverseitiger Technologien, wobei das
    Client-Server-Modell, serverseitige Verarbeitung und die Funktionsweise von
    Technologien wie PHP und CGI im Mittelpunkt stehen.
  </p>

  <h3>Client-Server-Modell</h3>
  <ul>
    <li>
      Der Client ist oft ein "schwächerer" Rechner, während der Server
      leistungsstärker ist.
    </li>
    <li>Beispiele für Clients: PC, Smartphone, Tablet.</li>
    <li>Beispiele für Server: WebServer, Host, Server Web 2.0.</li>
  </ul>

  <h3>Netzwerkkommunikation und serielle Technologien</h3>
  <p>
    In einem Netzwerk übernehmen Bridge und Switch eine wichtige Rolle. Sie
    steuern den Datenverkehr innerhalb eines Netzwerks und ermöglichen eine
    effiziente Kommunikation zwischen Geräten.
  </p>
  <ul>
    <li>
      <strong>Bridge:</strong> Verfolgt MAC-Adressen und leitet Pakete gezielt
      weiter.
    </li>
    <li>
      <strong>Switch:</strong> Multiport-Bridge, die Pakete innerhalb eines
      Netzwerks weiterleitet. Eliminieren Kollisionsdomänen (bei
      Mikrosegmentierung). Switches arbeiten hardwarebasiert.
    </li>
  </ul>
  <img
    class="lecture-image"
    src="pictures/01_content_4Semester/segmentierung_switches.png"
    alt="Segmentierung mit Switches"
  />
  <p class="image_des">Segmentierung mit Switches</p>

  <h3>Java Applets</h3>
  <p>
    Java-Applets ermöglichen Aktivität auf Client-seite. Sie sind jedoch
    aufgrund von Sicherheitsbedenken kaum noch verbreitet. Stattdessen werden
    Technologien wie CGI und PHP für dynamische Webinhalte genutzt.
  </p>
  <img
    class="lecture-image"
    src="pictures/01_content_4Semester/java_applets.png"
    alt="Java Applets"
  />
  <p class="image_des">Java Applets in Vereinfachter Darstellung</p>
  <h3>Moderne Alternativen</h3>
  <ul>
    <li>
      <strong>CGI:</strong> Ermöglicht das Abrufen von mehr als nur statischen
      Daten.
      <img
        class="lecture-image"
        src="pictures/01_content_4Semester/cgi_funktionsweiße.png"
        alt="CGI"
      />
      <p class="image_des">CGI Funktionsweise</p>
    </li>
    <li>
      <strong>PHP:</strong> Eine weit verbreitete Skriptsprache für dynamische
      Inhalte und Datenbankabfragen.
      <img
        class="lecture-image"
        src="pictures/01_content_4Semester/php_funktionsweiße.png"
        alt="PHP"
      />
      <p class="image_des">PHP Funktionsweise</p>
    </li>
    <li>Java Servlets & JSP</li>
    <li>JavaScript: node.js und darauf basierende libs/frameworks</li>
  </ul>

  <h3>JavaScript-Frameworks</h3>
  <p>
    JavaScript-Frameworks sind wichtig für die Entwicklung interaktiver und
    reaktionsschneller Webanwendungen.
  </p>

  <h3>Serialisierung</h3>
  <p>
    Serialisierung ermöglicht das Speichern von Objekten in einer Datei und das
    spätere Wiederherstellen ihres Zustands.
  </p>
  <ul>
    <li>
      Instanzvariablen werden ausgelesen und in eine computergängige Form
      umgewandelt.
    </li>
    <li>Der gesamte Objektgraph wird serialisiert.</li>
    <pre><code>
      FileOutputStream fileStream = new FileOutputStream(”MeinSpiel.ser”);
      ObjectOutputStream os = new ObjectOutputStream(fileStream);
              os.writeObject(figur1);
              os.writeObject(figur2);
              os.writeObject(figur3);
              os.close();
    </code></pre>
    <li>Hierfür muss die Klasse des Objektes "Serializable" implementieren</li>
    <li>
      Zudem muss ein try-catch block eingebaut werden da E-A Operationen
      Exceptions auslösen können
    </li>
    <li>Mit transient werden Instanzvariables nicht gespeichert</li>
  </ul>

  <h3>Deserialisierung</h3>
  <p>
    Bei der Deserialisierung werden Objekte in ihren ursprünglichen Zustand
    zurückgeführt.
  </p>
  <pre><code>
    FileInputStream fileStream = new FileInputStream("MeinSpiel.ser")
    ObjectInputStream is = new ObjectInputStream(fileStream);
    Spielfigur einsWiederhergestellt = (Spielfigur) is.readObject();
    Spielfigur zweiWiederhergestellt = (Spielfigur) is.readObject();
    Spielfigur dreiWiederhergestellt = (Spielfigur) is.readObject();
    is.close();
  </code></pre>
  <ul>
    <ol>
      <li>Das Objekt wird aus dem Strom gelesen.</li>
      <li>Die JVM bestimmt die Klasse des Objekts.</li>
      <li>
        Die JVM findet und lädt die Klasse – andernfalls wird eine Exception
        ausgelöst.
      </li>
      <li>
        Die Instanzvariablen des Objekts erhalten die Werte aus dem
        serialisierten Zustand.
      </li>
    </ol>
    <li>Fehlerhafte Typzuweisungen können zu Problemen führen.</li>
  </ul>
  <h3>Einführung in die Dateiverwaltung</h3>
  <p>
    Zur Speicherung von Daten wird der <code>FileWriter</code> verwendet. Mit
    diesem kann eine Datei geöffnet oder erstellt werden, und Daten in die Datei
    geschrieben werden.
  </p>
  <p>
    Für den Zugriff auf Dateien wird die <code>File</code>-Klasse verwendet, mit
    der es möglich ist, Objekte zu erzeugen, die eine Datei oder einen Pfad
    repräsentieren. Auch das Erstellen neuer Verzeichnisse ist mit dieser Klasse
    möglich.
  </p>
  <p>
    Zum effizienteren Schreiben von Daten wird der
    <code>BufferedWriter</code> genutzt. Dieser sammelt Daten in einem Puffer
    und schreibt sie erst dann in die Datei, wenn der Puffer voll ist.
  </p>
  <p>
    Ähnlich funktioniert das Lesen von Dateien mit einem
    <code>FileReader</code> und einem <code>BufferedReader</code>. Der
    <code>BufferedReader</code> liest Zeile für Zeile und verarbeitet jede Zeile
    nacheinander.
  </p>

  <h3>Einen String aus einer Textdatei lesen</h3>
  <pre><code>
    try{
      File meineDatei = new File("files/duda.txt");
      FileReader fileReader = new FileReader(meineDatei);

      BufferedReader reader = new BufferedReader(fileReader);

      String zeile = null;

      while((zeile = reader.readLine()) != null){
          System.out.println(zeile);
      }
      reader.close();

  }
  catch(Exception ex){
      ex.printStackTrace();
  }
  </code></pre>
  <h3>Einen String in eine Textdatei schreiben (kopieren)</h3>
  <pre><code>
    try{

      File dir = new File("files");
      String dirPath = dir.getAbsolutePath();

      File tFile = new File("files/names.txt");
      FileReader fileReader = new FileReader(tFile);
      BufferedReader reader = new BufferedReader(fileReader);

      FileWriter cFile = new FileWriter(dirPath + "/copy.txt");  

      String zeile = null;

      while((zeile = reader.readLine()) != null){
          cFile.write(zeile + "\n");
      }

      cFile.close();
      reader.close();

      }
      catch(Exception ex){
          ex.printStackTrace();
      }
  </code></pre>
</div>
